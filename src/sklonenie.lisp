;;;; sklonenie.lisp

(in-package #:eshop)

(defparameter *group-skls* (make-hash-table :test #'equal))

(defun skls.get-count-skls(count)
  (let ((cnt (mod count 100))
        (result 0))
    (if (>= cnt 20)
        (setf cnt (mod cnt 20)))
    (if (zerop cnt)
        (setf result 2)
        (if (= cnt 1)
            (setf result 0)
            (if (< cnt 5)
                (setf result 1)
                (setf result 2))))
    result))

(defun sklonenie.restore ()
  (let ((t-storage (make-hash-table :test #'equal)))
    (xls.restore-from-xls
     (merge-pathnames "sklonenija.xls" (config.get-option :paths :path-to-main-page))
     #'(lambda (line)
         (let* ((words (sklonenie-get-words line))
                (skls (mapcar #'(lambda (w) (string-trim "#\""  w))
                              words))
                (key (string-downcase (car skls))))
           (setf (gethash key t-storage) skls)))
     "sklonenie.restore")
    (setf *group-skls* t-storage)))

(defmethod sklonenie-get-words ((isg string))
  (let ((bin))
    (values
     (mapcar #'(lambda (y) (string-trim '(#\Space #\Tab) y))
             (mapcar #'(lambda (y) (regex-replace-all "\\s+" y " "))
                     (mapcar #'(lambda (y) (string-trim '(#\Space #\Tab #\") y))
                             (let ((inp) (sv) (ac) (rs))
                               (loop :for cr :across isg :do
                                  (if (null inp)
                                      (cond ((equal #\" cr) (setf inp t))
                                            ((equal #\, cr) (push "" rs)))
                                      (cond ((and (null sv) (equal #\" cr)) (setf sv t))
                                            ((and sv (equal #\" cr)) (progn (setf sv nil)
                                                                            (push #\" ac)))
                                            ((and sv (equal #\, cr)) (progn (setf sv nil)
                                                                            (setf inp nil)
                                                                            (push (coerce (reverse ac) 'string) rs)
                                                                            (setf ac nil)))
                                            ((equal #\Return cr) nil)
                                            (t (push cr ac)))))
                               (when ac
                                 (if (and inp (null sv))
                                     (setf bin t))
                                 (push (coerce (reverse ac) 'string) rs))
                               (reverse rs)))))
     bin)))

(defun sklonenie (name skl)
  (let* ((key (string-downcase name))
         (words (gethash key *group-skls*)))
    (if (null words)
        key
        (nth (- skl 1) words))))
